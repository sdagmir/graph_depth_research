doc_id: 14
Лекция 9 Архитектура фронтенда Разработка интернет приложений Канев Антон Игоревич
Классы фронтенда • Мы хотим объединить бэкенд и фронтенд • Но на 1 диаграмме все не поместиться • Поэтому для 5 лабораторной оставляем ТОЛЬКО страницы React и домены веб- сервиса
https://github.com/iu5git/PhotoPointApp Фронтенд ИУ5 https://github.com/iu5git/CampusMap https://github.com/iu5git/MapViewApp
Поток данных и сообщений
Методы жизненного цикла компонента
Функциональные компоненты • Описание компонентов с помощью чистых функций создает меньше кода, а значит его легче поддерживать. • Чистые функции намного проще тестировать. Вы просто передаете props на вход и ожидаете какую то разметку. • В будущем чистые функции будут выигрывать по скорости работы в сравнении с классами из-за отсутствия методов жизненного цикла • Все это стало возможным благодаря хукам hLps://react.dev/reference/react
Хуки
Другие хуки • useContext: позволяет работать с контекстом — с механизмом для организации совместного доступа к данным без передачи свойств. • useReducer: усложняет useState добавляя разделение логики в зависимости от action. Вместе с useContext дают аналог Redux.
Другие хуки • useMemo: используется для возврата мемоизированного значения. Может применяться, чтобы функция возвратила кешированное значение. • Можно сохранить результаты вычислений между вызовами render
React Router Hooks • useLocation: все данные о текущем пути url • useNavigate: объект истории браузера • useParams: параметры из url • h"ps://reactrouter.com/
Breadcrumbs Для навигации пользователя по страницам нашего приложения будем использовать • Самописные Хлебные крошки • Навигационную панель (меню) из react-bootstrap
Breadcrumbs, поиск • Создаем наш собственный компонент для реализации хлебных крошек • В поиске ждем событие onSubmit, в котором используем состояние searchValue
Mock • В реальной жизни бывает очень сложно связать фронтенд и бэкенд вместе: что-то не готово, проблемы с развертывание или Cors • Поэтому бэкенд проверяем через Swagger/Postman, а для фронтенда готовим Mock
Обратный прокси-сервер для CORS • Одно из решений - отправляем запросы на напрямую в веб- сервис, а проксируем через наш сервер фронтенда • Похоже на prod решение при проксировании через Nginx
BFF и GraphQL • GraphQL – язык запросов и сервер, который с открытым исходным кодом • Backend for frontend – шлюз к нашим API, адаптированный под каждого из потребителей: веб-приложение, мобильное, десктоп
Микрофронтенды • В одном интерфейсе несколько фронтенд фреймворков: разные команды фронтенд разработчиков, разные API • Одни из способов уйти от зависимости от одной технологии и постепенно внедрять новую
Next.js • SPA сильный инструмент, но как индексировать в поисковиках? На странице нет никаких данных • Для этого используем серверные компоненты Next.js • Хуков нет: данные передаем через props • SSG (Static Site Generation) – HTML генерируется при сборке приложения
Рассмотрим приложение социальной сети. FSD • app/ содержит настройку роутера, глобальные хранилища и стили. • pages/ содержит компоненты роутов на каждую страницу в приложении, преимущественно композирующие, по возможности, без собственной логики. В рамках этого приложения рассмотрим карточку поста в ленте новостей. • widgets/ содержит "собранную" карточку поста, с содержимым и интерактивными кнопками, в которые вшиты запросы к бэкенду. • features/ содержит всю интерактивность карточки (например, кнопку лайка) и логику обработки этой интерактивности. • entities/ содержит скелет карточки со слотами под интерактивные элементы. Компонент, демонстрирующий автора поста, также находится в этой папке, но в другом слайсе. • h"ps://feature-sliced.design/ru/docs/get-started/overview
Архитектура FSD Слои стандартизированы во всех проектах и расположены вертикально. Модули на одном слое могут взаимодействовать лишь с модулями, находящимися на слоях строго ниже. На данный момент слоев семь (снизу вверх): 1.shared — переиспользуемый код, не имеющий отношения к специфике приложения/бизнеса (например, UIKit, libs, API) 2.entities (сущности) — бизнес-сущности (например, User, Product, Order) 3.features (фичи) — взаимодействия с пользователем, действия, которые несут бизнес- ценность для пользователя (например, SendComment, AddToCart, UsersSearch) 4.widgets (виджеты) — композиционный слой для соединения сущностей и фич в самостоятельные блоки (например, IssuesList, UserProfile). 5.pages (страницы) — композиционный слой для сборки полноценных страниц из сущностей, фич и виджетов. 6.processes (процессы, устаревший слой) — сложные сценарии, покрывающие несколько страниц (например, авторизация) 7.app — настройки, стили и провайдеры для всего приложения.
Архитектура FSD • Затем есть слайсы, разделяющие код по предметной области. Они группируют логически связанные модули, что облегчает навигацию по кодовой базе. Слайсы не могут использовать другие слайсы на том же слое, что обеспечивает высокий уровень связности (cohesion) при низком уровне зацепления (coupling). • В свою очередь, каждый слайс состоит из сегментов. Это маленькие модули, главная задача которых — разделить код внутри слайса по техническому назначению. Самые распространенные сегменты — ui, model (store, actions), api и lib(utils/hooks), но в вашем слайсе может не быть каких-то сегментов, могут быть другие, по вашему усмотрению.
Преимущества FSD Единообразие • Код распределяется согласно области влияния (слой), предметной области (слайс) и техническому назначению (сегмент). Благодаря этому архитектура стандартизируется и становится более простой для ознакомления. Контролируемое переиспользование логики • Каждый компонент архитектуры имеет свое назначение и предсказуемый список зависимостей. Благодаря этому сохраняется баланс между соблюдением принципа DRY и возможностью адаптировать модуль под разные цели. Устойчивость к изменениям и рефакторингу • Один модуль не может использовать другой модуль, расположенный на том же слое или на слоях выше. Благодаря этому приложение можно изолированно модифицировать под новые требования без непредвиденных последствий. Ориентированность на потребности бизнеса и пользователей • Разбиение приложения по бизнес-доменам помогает глубже понимать, структурировать и находить фичи проекта.
Пример FSD • В нашем GitLab доступен простой пример по FSD - рекомендуется для дипломной работы. • В нем каждый слой состоит из слайсов, например, Header, LoginPage и так далее. • https://projects.iu5.bmstu.ru/iu5/infrastructure/department-services/templates/react
doc_id: 13
Лекция 8 Введение в React Разработка интернет приложений Канев Антон Игоревич
Про телепортацию • Можно создать два генератора случайных чисел в разных местах • Но для передачи информации нужен обычный канал –ы осмысленный сигнал передать быстрее света не получится
Трехзвенная архитектура. AJAX • На диаграмме развертывания мы указали наши бэкенд и фронтенд • Указали IP и номера портов, которые используются этими приложениями • Указать реверс – прокси!
Web-фреймворки. Фронтенд • Есть большое множество фреймворков для разработки фронтенд приложений на JS/TS • Самым распространенным в России и в мире является React • Поддерживается компанией из BigTech.
DOM • Основой HTML-документа являются теги. • В соответствии с объектной моделью документа («Document Object Model», коротко DOM), каждый HTML-тег является объектом. Вложенные теги являются «детьми» родительского элемента. Текст, который находится внутри тега, также является объектом. • Все эти объекты доступны при помощи JS • Можем использовать их для изменения страницы.
React • Библиотека для работы с виртуальным DOM • Документация https://reactjs.org/docs/getting-started.html
React • Но окружение React не ограничивается только виртуальным DOM • Это запросы к API, библиотеки компонентов, хранение данных и тд
Компоненты • React-компоненты — это повторно используемые части кода, которые возвращают React-элементы для отображения на странице. • Функциональные и классовые компоненты
Props • props (пропсы) — это входные данные React-компонентов, передаваемые от родительского компонента дочернему компоненту. • В любом компоненте доступны props.children. Это контент между открывающим и закрывающим тегом компонента. • Для классовых компонентов используйте this.props.children
Состояние • Компонент нуждается в state, когда данные в нём со временем изменяются. • Например, компоненту Checkbox может понадобиться состояние isChecked. • Разница между пропсами и состоянием заключается в основном в том, что состояние нужно для управления компонентом, а пропсы для получения информации.
Поток данных и сообщений
Жизненный цикл приложения • 1: Монтирование компонент запускает getDerivedStateFromProps(), потом запускается render(), возвращающий JSX. React «монтируется» в DOM • 2: Обновление Данный этап запускается во время каждого изменения состояния либо свойств • 3: Размонтирование React выполняет запуск componentWillUnmount() непосредственно перед удалением из DOM
Методы жизненного цикла компонента
useEffect • componentDidMount() • Не путать useEffect и • componentDidUpdate() жизненный цикл – ЭТО • componentWillUnmount() РАЗНЫЕ ВЕЩИ • Жизненный цикл это гораздо более широкое понятие: работа с props, render, отслеживание состояний и тд • useEffect это только 3 события: зеленые блоки из предыдущей схемы
Функциональные компоненты • Описание компонентов с помощью чистых функций создает меньше кода, а значит его легче поддерживать. • Чистые функции намного проще тестировать. Вы просто передаете props на вход и ожидаете какую то разметку. • В будущем чистые функции будут выигрывать по скорости работы в сравнении с классами из-за отсутствия методов жизненного цикла • Все это стало возможным благодаря хукам https://react.dev/reference/react
Хуки
Хуки. useState • Хуки позволяют работать с состоянием компонентов, с методами их жизненного цикла, с другими механизмами React без использования классов.
Vite • Окружение для разработки и сборщик • Мы используем Vite вместо CRA • Поддерживает React и Vue.js • Поддерживает ряд возможностей
Структура проекта Vite В папке проекта у нас будут следующие файлы: • package.json основной файл с информацией о проекте • package-lock.json лок файл со списком зависимостей • vite.config.ts конфигурационный файл сборщика Vite • tsconfig.json конфигурационный файл TypeScript • tsconfig.node.json конфигурационный файл TypeScript при запуске на Node • .eslintrc.cjs конфигурационный файл Eslint • index.html основной файл нашего приложения. Он будет первым загружаться, когда пользователь заходит на страницу • src/main.tsx основной TS файл нашего приложения. Тут мы запускаем отрисовку приложения • src/App.tsx верстка приложения. Логотип Vite и React
ES6 • ECMAScript 2015
Babel • Компилятор JS
WebPack в CRA • Vite – альтернатива Create React App • Сборщик модулей JS • webpack принимает модули с зависимостями и генерирует статические ресурсы, представляющие эти модули
JSX • JSX — расширение синтаксиса JavaScript. TSX – то же, но для TS • Этот синтаксис выглядит как язык шаблонов, но наделён всеми языковыми возможностями JavaScript. Родился из XHP для PHP • В результате компиляции JSX возникают простые объекты — «Reactэлементы». • React DOM использует стиль именования camelCase для свойств вместо обычных имён HTML-атрибутов. • Например, в JSX атрибут tabindex станет tabIndex. • В то время как атрибут class записывается как className, поскольку слово class уже зарезервировано в JavaScript
Create React App vs Vite + React
Основные файлы • index.html • main.js
App.tsx • Первый и главный компонент нашего приложения • В шаблоне уже есть кнопка, хук состояния
Роутинг • Добавляем роутер в main.js для обработки переходов по url нашего приложения • Пока заменили наш компонент App.tsx на простые элементы • Получить мы их можем если введем нужный url
Router • Добавляем новый общий элемент с ссылками на страницы нашего приложения • Нам теперь не нужно вводить вручную url, можем просто нажать ссылку
Cors • CORS мы получили страницу с одного домена, а запросы отправляем на другой Как решить? • CORS – заголовки на бекенде • Проксирование через сервер фронтенда
Обратный прокси-сервер для CORS • Одно из решений отправляем запросы на напрямую в вебсервис, а проксируем через наш сервер фронтенда • Похоже на prod решение при проксировании через Nginx
React-Bootstrap vs MUI
Figma MUI • Набор компонентов MUI доступен в Figma • Можно создать дизайн, используя готовые компоненты, иконки